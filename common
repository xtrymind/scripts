#!/usr/bin/env bash

# Location of "scripts" folder
SCRIPTS_FOLDER=$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" || return; pwd)

# Directory
LOS=${HOME}/local/lineage
TC_FOLDER=${HOME}/local/toolchains
FOLDER_MAGISK=${HOME}/repo/magisk-files
KERNEL_FOLDER=${HOME}/local/kernel
BIN_FOLDER=${HOME}/bin

# Colors
BLINK_RED="\033[05;31m"
BLUE="\033[01;34m"
BOLD="\033[1m"
GRN="\033[01;32m"
RED="\033[01;31m"
RST="\033[0m"
YLW="\033[01;33m"

# Number of make threads
THREADS=$(($(nproc --all) + 1))
JOBS_FLAG="-j${THREADS}"

# Common ccache variable
CCACHE=$(command -v ccache)

if [ -d "$HOME/bin" ] ; then
    PATH="$HOME/bin:$PATH"
fi

# Add path for comvert
if [ -d "${HOME}/repo/comvert" ] ; then
    PATH="${HOME}/repo/comvert:$PATH"
fi

# Use ccache
export USE_CCACHE=true;
export PATH="/usr/lib/ccache/bin/:$PATH"
if [[ ! -d ${CCACHE_DIR} ]]; then
    ccache -M 20G &> /dev/null
    ccache --set-config=compression=true
    ccache --set-config=compression_level=9
fi

# Sync repo
function rps {
    repo sync -j4 --force-sync -c --no-clone-bundle --no-tags --optimized-fetch --prune "${@}" #|& rg --color=never --after-context=3 "git:" && echo
}

# Set up android build environment
function envrom(){
    export PATH="/opt/python2:$PATH"
    export LC_ALL=C
}

# Brunch with cmka for build lineage
function bcmka(){
	[[ ${#} -lt 1 ]] && { display_error "This function takes an argument!"; return; }

	DEVICE=${1}

	breakfast ${DEVICE}
	cmka bacon
}

# Create config based on modprobed.db
function localmodcfg(){
    make LSMOD=${HOME}/.config/modprobed.db localmodconfig
}

# Alias for echo to print escape codes
function echo() {
    command echo -e "${@}"
}

# Prints a formatted header to point out what is being done to the user
function header() {
    if [[ -n ${2} ]]; then
        COLOR=${2}
    else
        COLOR=${RED}
    fi
    echo "${COLOR}"
    echo "====$(for i in $(seq ${#1}); do echo "=\c"; done)===="
    echo "==  ${1}  =="
    # SC2034: i appears unused. Verify it or export it.
    # shellcheck disable=SC2034
    echo "====$(for i in $(seq ${#1}); do echo "=\c"; done)===="
    echo "${RST}"
}

# Enforces the value needed for two-part flags
function enforce_value() {
    [[ ${#} -lt 1 ]] && die "A additional value is needed for one of the flags passed to this script!"
}

# Prints an error in bold red
function display_error() {
    echo
    echo "${RED}${1}${RST}"
    [[ -z ${2} ]] && echo
}

# Prints an error in bold red and exits the script
function die() {
    display_error "${@}"
    if type -p pre_exit_commands; then
        pre_exit_commands
    fi
    exit
}

# Prints a warning in bold yellow
function warn() {
    echo
    echo "${YLW}${1}${RST}"
    [[ -z ${2} ]] && echo
}

# Formats the time
function format_time() {
    MINS=$(((${2} - ${1}) / 60))
    SECS=$(((${2} - ${1}) % 60))
    if [[ ${MINS} -ge 60 ]]; then
        HOURS=$((MINS / 60))
        MINS=$((MINS % 60))
    fi

    if [[ ${HOURS} -eq 1 ]]; then
        TIME_STRING+="1 HOUR, "
    elif [[ ${HOURS} -ge 2 ]]; then
        TIME_STRING+="${HOURS} HOURS, "
    fi

    if [[ ${MINS} -eq 1 ]]; then
        TIME_STRING+="1 MINUTE"
    else
        TIME_STRING+="${MINS} MINUTES"
    fi

    if [[ ${SECS} -eq 1 && -n ${HOURS} ]]; then
        TIME_STRING+=", AND 1 SECOND"
    elif [[ ${SECS} -eq 1 && -z ${HOURS} ]]; then
        TIME_STRING+=" AND 1 SECOND"
    elif [[ ${SECS} -ne 1 && -n ${HOURS} ]]; then
        TIME_STRING+=", AND ${SECS} SECONDS"
    elif [[ ${SECS} -ne 1 && -z ${HOURS} ]]; then
        TIME_STRING+=" AND ${SECS} SECONDS"
    fi

    echo "${TIME_STRING}"
}

# Convert a file location to gitlab web link
function web_link_gitlab() {
    echo "${1}" | sed s/"$(echo "${FOLDER_MAGISK}" | sed 's/\//\\\//g')"/https:\\/\\/gitlab.com\\/xtrymind\\/magisk-files\\/raw\\/master/
}

# Convert a file location to github web link
function web_link_github() {
    echo "${1}" | sed s/"$(echo "${FOLDER_MAGISK}" | sed 's/\//\\\//g')"/https:\\/\\/raw.githubusercontent.com\\/xtrymind\\/magisk-files\\/master/
}

# Remove URLs from Clang version
function clang_version() {
    [[ ${#} -lt 1 ]] && { display_error "This function takes an argument!"; return; }

    local CLANG POS
    CLANG=${1}
    if [[ $(basename "${CLANG}") != "clang" ]]; then
        CLANG=$(find "${CLANG}" -name clang | head -n1)
        [[ -z ${CLANG} ]] && { display_error "You didn't supply a Clang folder/binary!"; return; }
    else
        [[ ! -f ${CLANG} ]] && { display_error "Clang binary supplied doesn't exist!"; return; }
    fi

    case "${CLANG}" in
        *linux-x86*) POS="1,2" ;;
        *) POS="1" ;;
    esac
    "${CLANG}" --version | head -n 1 | cut -d \( -f "${POS}" | sed 's/[[:space:]]*$//' || display_error "Something went wrong!"
}

# Common function for file management
# make cbz file from all folder in current dirrectory
function mkacbz() {
    for dir in */; do base=$(basename "$dir"); zip -r9 "${base}.cbz" "$dir"; done
}

# convert zip file to cbz in current dirrectory
function cvcbz() {
    for file in *.zip; do mv "$file" "${file%.zip}.cbz"; done
}

# remove colon(":") from file name
function rmcolon() {
    for file in *.cbz; do mv "$file" "$(echo "$file" | sed 's/[^a-zA-Z0-9.[:space:]]//g')"; done
}

# ripgrep wrapper
function rg() {
    # Bail out if rg is not installed
    command -v rg &>/dev/null || { warn "ripgrep is not installed!"; return; }

    # Colors match ag
    command rg --colors "path:fg:green" \
               --colors "path:style:bold" \
               --colors "line:fg:yellow" \
               --colors "line:style:bold" \
               --colors "column:fg:yellow" \
               --colors "column:style:bold" \
               "${@}"
}

# Add a remote if it doesn't exist
function add_remote() {
    if ! git remote | grep -q -m 1 "${1}"; then
        git remote add "${1}" "${2}"
    fi
}
