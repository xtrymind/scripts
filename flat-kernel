#!/usr/bin/env bash
#
# SPDX-License-Identifier: GPL-3.0-or-later
#
# Copyright (C) 2016-2018 Nathan Chancellor
# Copyright (C) 2018 Dede Dindin Qudsy
#
# Kernel compilation script

source ${HOME}/dotfiles/common

# directory
SOURCE_FOLDER=${KERNELDIR}/mido
#SOURCE_FOLDER=${KERNELDIR}/msm-3.18
OUT_FOLDER=${SOURCE_FOLDER}/out
ANYKERNEL2_FOLDER=${HOME}/kernel/AnyKernel2
BIN_FOLDER=${HOME}/bin
TC_FOLDER=${HOME}/tc

# variable
ARCHITECTURE=arm64
DEVICE_NAME_GITHUB=mido
KERNEL_BRANCH=flat

# Common ccache variable
CCACHE=$(command -v ccache)

# Start tracking time
START=$(date +"%s")

# toolchain
CLANG="${HOME}/tc/clang-7.x/bin/clang"
CLANG_FOLDER=${HOME}/tc/clang-7.x/

# Number of make threads
THREADS=$(nproc --all)
JOBS_FLAG="-j${THREADS}"

LLVM_DIS=${CLANG_FOLDER}/bin/llvm-dis
CLANG_LD_PATH=${CLANG_FOLDER}/lib

# Gather parameters
function parse_parameters() {
    # Unset the universal OS variable for this script only
    PARAMS="${*}"
    EXTRA_MAKE_FLAGS=()
    while [[ ${#} -ge 1 ]]; do
        case ${1} in
            # Compiler to use
            "-cc"|"--compiler")
                shift && enforce_value "${@}"

                COMPILER=${1} ;;

            # Where to move zip after compilation
            "-m"|"--mode")
                shift && enforce_value "${@}"

                MODE=${1} ;;

            # Don't move/delete zips in FILE_MOVE folder
            "-n"|"--no-clean")
                NOCLEAN=true ;;

            # Test versioning (# in kernel version)
            "-r"|"--revision")
                shift && enforce_value "${@}"

                REVISION=${1} ;;

            # Version number
            "-v"|"--version")
                shift && enforce_value "${@}"

                VERSION=${1} ;;

            # beta
            "-b"|"--beta")
                shift && enforce_value "${@}"

                BETA=${1} ;;

            # Disables -Werror config
            "-Wno-error")
                NO_WERROR=true ;;

            *)
                die "Invalid parameter" ;;
        esac

        shift
    done

    # Default parameters
    [[ -z ${DEVICE} ]] && DEVICE="mido"
    [[ -z ${MODE} ]] && MODE="personal"

    # Easy to use variables for if statements
    [[ ${MODE} != "stable" ]] && NOT_STABLE=true || STABLE=true
    [[ ${MODE} = "personal" ]] && PERSONAL=true || PERSONAL=false

}

function device_flags() {
    case ${DEVICE} in
        "mido")
            [[ -z ${COMPILER} ]] && COMPILER=clang

            [[ -z ${DEFCONFIG} ]] && DEFCONFIG="flat_defconfig"

            DEVICE_NAME_FILE=${DEVICE^}
            DEVICE_NAME_GITHUB=mido
            DEVICE_NAME_WEB=${DEVICE} 
            
            [[ -z ${GCC_FOLDER} ]] && GCC_FOLDER=${TC_FOLDER}/aarch64-linux-gnu
            #GCC="${HOME}/tc/aarch64-linux-gnu/bin/aarch64-linux-gnu-"
			#GCC="${HOME}/tc/aarch64--glibc--bleeding-edge-2018.06-1/bin/aarch64-buildroot-linux-gnu-"
            ;;

        *)
            die "Invalid device!" ;;
    esac
}

# Easy alias for escape codes
function echo() {
    command echo -e "$@"
}

# Prints an error in bold red and exits the script
function die() {
    display_error "${@}"
    if type -p pre_exit_commands; then
        pre_exit_commands
    fi
    exit
}

# Enforces the value needed for two-part flags
function enforce_value() {
    [[ ${#} -lt 1 ]] && die "A additional value is needed for one of the flags passed to this script!"
}

# Prints a formatted header to let the user know what's being done
function header() {
    echo ${RED}
    echo "====$(for i in $(seq ${#1}); do echo "=\c"; done)===="
    echo "==  ${1}  =="
    echo "====$(for i in $(seq ${#1}); do echo "=\c"; done)===="
    echo ${RST}
}

# Make wrapper for make function for GCC
function make_wrapper_gcc() {
    make "${JOBS_FLAG}" \
         ARCH=${ARCHITECTURE} \
         CROSS_COMPILE="${CCACHE} ${GCC}" \
         KBUILD_BUILD_VERSION="${KBUILD_BUILD_VERSION}" \
         LOCALVERSION="${LOCALVERSION}" \
         O="${OUT_FOLDER}" \
         "${@}"
}

# Make wrapper for make function for Clang
function make_wrapper_clang() {
	LD_LIBRARY_PATH="${CLANG_LD_PATH}:${LD_LIBARY_PATH}" \
    make "${JOBS_FLAG}" \
         ARCH=${ARCHITECTURE} \
         CC="${CCACHE} ${CLANG}" \
         CLANG_TRIPLE=aarch64-linux-gnu- \
         CROSS_COMPILE="${GCC}" \
         HOSTCC="${CCACHE} ${CLANG}" \
         KBUILD_COMPILER_STRING="${CLANG_VERSION}" \
         KBUILD_BUILD_VERSION="${KBUILD_BUILD_VERSION}" \
         KBUILD_BUILD_TIMESTAMP="${TIMESTAMP}" \
         KCFLAGS="${KCFLAGS}" \
         LLVM_DIS="${LLVM_DIS}" \
         LOCALVERSION="${LOCALVERSION}" \
         O="${OUT_FOLDER}" \
         "$@"
}
         #EXTRAVERSION=${EXVERSION}
# Silence output function
function kmake() {
        make_wrapper_${COMPILER} "${@}"
}

function clv(){
	cp ${OUT_FOLDER}/.version /tmp/
	git clean -dfx
	mkdir ${OUT_FOLDER}
	mv /tmp/.version ${OUT_FOLDER}
}

# Build kernel image
function build_kernel() {
    # Clean source folder
    #git clean -dfx
    clv

    # Point to proper defconfig and generate version files
    kmake ${DEFCONFIG} prepare

    # Make the kernel
    kmake 2>&1 | tee ../kernel.log

    # Find the compiled files
    OUT_KERNEL_IMAGE=$(find "${OUT_FOLDER}/arch/${ARCHITECTURE}" -name 'Image.*-dtb' 2>/dev/null)

    # Move them if they exist, error out if not
    if [[ -n ${OUT_KERNEL_IMAGE} ]]; then
        echo "${GRN}${OS_STRING}$(basename "${OUT_KERNEL_IMAGE}") compiled successfully!${RST}\n"
        move_kernel_files
    else
        echo "${RED}Kernel image not found!${RST}\n"
        #ending_info
    fi
}

# Set up other variables
function generate_variables() {
    GCC_BIN=$(find "${GCC_FOLDER}/bin" \( -type f -o -type l \) -name '*-gcc' | head -n1)
    [[ -z ${GCC_BIN} ]] && die "64-bit GCC toolchain could not be found!"
    GCC=${GCC_BIN%gcc}
	
	CLANG_VERSION=$(${CLANG} --version | head -n 1 | perl -pe 's/\(http.*?\)//gs' | sed -e 's/  */ /g' -e 's/[[:space:]]*$//')
    CLANG_LD_PATH=${CLANG_FOLDER}/lib
    if [[ ${MODE} = "personal" ]]; then
		KCFLAGS="-mllvm -polly \
				 -mllvm -polly-run-dce \
				 -mllvm -polly-run-inliner \
				 -mllvm -polly-opt-fusion=max \
				 -mllvm -polly-ast-use-context \
				 -mllvm -polly-vectorizer=stripmine \
				 -mllvm -polly-detect-keep-going"
	fi
}

# Move kernel files after compilation
function move_kernel_files() {
        # Move the kernel image
        cp "${OUT_KERNEL_IMAGE}" "${ANYKERNEL2_FOLDER}"
        [[ -n ${OUT_DTBO_IMAGE} ]] && cp "${OUT_DTBO_IMAGE}" "${ANYKERNEL2_FOLDER}/dtbo"
        echo "Version: $(cat "${OUT_FOLDER}/include/config/kernel.release")" > "${ANYKERNEL2_FOLDER}/version"
}

# Package zip
function package_zip() {
    header "PACKAGING AND SIGNING ZIP"

    echo "${BOLD}Signed zip name:${RST}   ${SIGNED_ZIP}\n"

    cd "${ANYKERNEL2_FOLDER}" || die "AnyKernel2 folder shift failed!"

    # Package the zip without the README
    zip -r9 "${UNSIGNED_ZIP}" -x README.md -- *

    # Sign zip
    java -jar "${BIN_FOLDER}/zipsigner-2.1.jar" \
              "${UNSIGNED_ZIP}" \
              "${SIGNED_ZIP}"

    # If packaging failed, error out
    if [[ ! -f ${SIGNED_ZIP} ]]; then
        echo "${RED}Kernel zip not found after signing!${RST}\n"
        ending_info
    else
        echo "${GRN}Kernel zip successfully generated!${RST}\n"
        rm ${UNSIGNED_ZIP}
        #cp ${SIGNED_ZIP} ${HOME}
        echo "${GRN}Kernel located at "${HOME}/${SIGNED_ZIP}" ${RST}\n"
        echo "Time elapsed: $(format_time "${START}" "$(date +"%s")")"
    fi
}

# Clean up
function clean_up() {
    # Clean AnyKernel2 folder
    cd "${ANYKERNEL2_FOLDER}" || die "AnyKernel2 source is missing!"
    git clean -xfd
}

# Setup compilation
function generate_version() {
    # Generate kernel version
    KVER=$(make kernelversion)

    # This is set in the defconfig
    CONFIG_LOCALVERSION="-flat"
	
	CONFIG_KERNELNAMEZIP="flatKernel"
    #LOCALVERSION="-mido"
    LOCALVERSION_ZIP="-mido"
	
	# date in utc
	TIMESTAMP=$(date -u)

	# build version
	RVER=$(git tag | wc -l)
	#KBUILD_BUILD_VERSION=${RVER}

    # Add version if present
    if [[ -n ${VERSION} ]]; then
        VERSION_TEXT="-v${VERSION}"
        #LOCALVERSION="${LOCALVERSION}${VERSION_TEXT}"
    else
		RV=$(($(cat ${OUT_FOLDER}/.version)+1))
		VERSION_TEXT="-r${RV}"
    fi

    if [[ -n ${BETA} ]]; then
		BETA_TEXT="-${BETA}"
		#LOCALVERSION="${LOCALVERSION}${BETA_TEXT}"
    fi

    # If the mode isn't stable, add hash information to the file for debugging
        # Furthermore, if it is a personal build, use a shorter hash length
    NUM=12
    SHA="-g$(git rev-parse --verify --short=${NUM} HEAD)"
    LOCALVERSION="${LOCALVERSION}${SHA}"

        # Don't add the hash to the zip name for personal builds, use the date instead
        #if [[ ${MODE} = "personal" ]]; then
        #    unset SHA
        #    DATE="-$(date +%Y%m%d-%H%M)"
        #fi

    # If there are uncommitted changes, mark as dirty
    if [[ $( git diff-index --name-only HEAD ) ]]; then
        DIRTY="-dirty"
        LOCALVERSION="${LOCALVERSION}${DIRTY}"
    fi

    # Generate first line variable
    # CONFIG_LOCALVERSION_AUTO is disabled
    #FIRST_LINE="${KVER}${CONFIG_LOCALVERSION}${LOCALVERSION}"

    # If REVISION exists, use it for the file
    if [[ -n ${REVISION} ]]; then
        REVISION_FOR_FILE=".${MODE::1}${REVISION}"
        RVER=$(git tag | wc -l)

        # If REVISION is greater than or equal to 1, pass it to the build system
        [[ ${REVISION} -ge 1 ]] && KBUILD_BUILD_VERSION=${REVISION}
    fi

    # Generate second line variable
    SECOND_LINE="$(whoami)@$(uname -n) #${KBUILD_BUILD_VERSION:-1}"

    # Generate third line variable
    #THIRD_LINE="$(date)"
    #DATE="-$(date +%Y%m%d)"
    #DATE="-$(date +%Y%m%d-%H%M)"

    # Export KERNEL_NAME based on the above information
    KERNEL_NAME="${CONFIG_KERNELNAMEZIP}${LOCALVERSION_ZIP}${VERSION_TEXT}${BETA_TEXT}${REVISION_FOR_FILE}${DATE}"

    UNSIGNED_ZIP=${KERNEL_NAME}-unsigned.zip
    SIGNED_ZIP=${KERNEL_NAME}.zip
}

# Generate changelog
function generate_changelog() {
    echo "  - Generating changelog"

    GITHUB="http://github.com/xtrymind"
    CHANGELOG=${HOME}/flat${VERSION_TEXT}-changelog.txt

    # Kernel source first
    cd "${SOURCE_FOLDER}" || die "Kernel source is missing!"

    # We need to mark the previous tag for changelog
    PREV_TAG_NAME=$(git tag --sort=-taggerdate | head -n 1)
    [[ -z ${PREV_TAG_NAME} ]] && return
    RANGE=${PREV_TAG_NAME}..HEAD

    # Show where commits are located
    {
        echo "${GITHUB}/${DEVICE_NAME_GITHUB}/commits/${KERNEL_BRANCH}\n"

        # Use shortlog for pretty output
        git log "${RANGE}" | git shortlog

        # Generate a diff as well
        git diff --find-renames --stat --summary "${RANGE}"
    } > "${CHANGELOG}"

    # Copy short changelog for FKU
    #[[ ${STABLE} ]] && cp "${SHORT_CHANGELOG}" "${FILE_MOVE}/.changelog"
}


header "COMPILING KERNEL"
parse_parameters "${@}"
device_flags
clean_up
cd ${SOURCE_FOLDER}
generate_variables
# Generate variables such as versions
generate_version
#generate_changelog
build_kernel
package_zip
