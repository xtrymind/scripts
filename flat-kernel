#!/usr/bin/env bash
#
# SPDX-License-Identifier: GPL-3.0-or-later
#
# Copyright (C) 2016-2019 Nathan Chancellor
# Copyright (C) 2018-2019 Dede Dindin Qudsy
#
# Flat Kernel compilation script

source "$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" || return; pwd)/common"

parse_parameters() {
    while (( ${#} )); do
        case ${1} in
            # Device to compile for
            "-d"|"--device")
                shift && enforce_value "${@}"

                DEVICE=${1} ;;

            # Do not package kernel image
            -b | --build-only)
                BUILD_ONLY=true ;;

            # Do not clean out directory
            -c | --clean)
                CLEAN=true ;;

            # Compiler to use
            "-cc"|"--compiler")
                shift && enforce_value "${@}"

                COMPILER=${1} ;;
            "") ;;

            *)
                die "Invalid parameter" ;;
        esac
        shift
    done

    # Default parameters
    [[ -z ${DEVICE} ]] && DEVICE="ginkgo"

    [[ -z ${COMPILER} ]] && COMPILER=clang

}

parse_parameters "$@"

TC_FOLDER=${HOME}/local/toolchains
KERNEL_FOLDER=${HOME}/local/kernel

AK3=${KERNEL_FOLDER}/AnyKernel3-${DEVICE}
FILE_MOVE=${HOME}/flatKernel/${DEVICE}

# default makeflags
MAKEFLAGS=(
    ${JOBS_FLAG}
    ARCH=arm64
    O=out
)

# Ccache
if [[ -n $(command -v ccache) ]]; then
    if [[ ${COMPILER} = "clang" ]]; then
        CC+="ccache "
    else
        CROSS_COMPILE+="ccache "
        CROSS_COMPILE_ARM32+="ccache "
    fi
fi

# Handle Clang
if [[ ${COMPILER} = "clang" ]]; then
    CLANG_FOLDER=${TC_FOLDER}/clang
    GCC_FOLDER=${TC_FOLDER}/arm64-gcc/bin
    GCC_CC=aarch64-elf-
    GCC_32_BIT_FOLDER=${TC_FOLDER}/arm32-gcc/bin
    GCC_32_BIT_CC=arm-eabi-
    CC+=clang

    CLANG_BIN=${CLANG_FOLDER}/bin
    [[ ! -f ${CLANG_BIN}/clang ]] && die "Clang binary could not be found!"

    CLANG_VERSION=$(clang_version "${CLANG_BIN}")
    MAKEFLAGS+=(
        "CC=${CC}"
        "CLANG_TRIPLE=aarch64-linux-gnu"
        "CLANG_TRIPLE_ARM32=arm-linux-gnueabi"
        "KBUILD_COMPILER_STRING=${CLANG_VERSION}"
        "AR=llvm-ar"
        "NM=llvm-nm"
        "OBJCOPY=llvm-objcopy"
        "OBJDUMP=llvm-objdump"
        "STRIP=llvm-strip"
    )
    # LD_LIBRARY_PATH is needed for LTO
    export LD_LIBRARY_PATH=${CLANG_FOLDER}/lib:$LD_LIBRARY_PATH
    export PATH=${CLANG_BIN}:$PATH
else
    # Handle GCC
    GCC_FOLDER=${TC_FOLDER}/aarch64-linux-android-4.9/bin
    GCC_CC=aarch64-linux-android-
    GCC_32_BIT_FOLDER=${TC_FOLDER}/arm-linux-androideabi-4.9/bin
    GCC_32_BIT_CC=arm-linux-androideabi-
fi

export PATH=${GCC_FOLDER}:${GCC_32_BIT_FOLDER}:$PATH
CROSS_COMPILE+="${GCC_CC}"
CROSS_COMPILE_ARM32+="${GCC_32_BIT_CC}"

# common makeflags
MAKEFLAGS+=(
    CROSS_COMPILE=${CROSS_COMPILE}
    CROSS_COMPILE_ARM32=${CROSS_COMPILE_ARM32}
    LOCALVERSION="${LOCALVERSION}"
)

# Start tracking time
START=$(date +"%s")

if [[ -z $CLEAN ]]; then
# clean build
make ARCH=arm64 O=out clean
rm -f out/arch/arm64/boot/Image.gz-dtb
fi

# Point to proper defconfig and generate version files
make ARCH=arm64 O=out ${DEVICE}_defconfig

if [[ ${HOSTNAME} = "ubox" ]]; then
       ./scripts/config --file out/.config --disable CONFIG_THINLTO
fi

make "${MAKEFLAGS[@]}"

if [[ -z $BUILD_ONLY ]]; then
    if [[ ! -f "out/arch/arm64/boot/Image.gz-dtb" ]]; then
        echo "Kernel image not found!"
        exit 0
    fi
    # Clean everything except zip files
    git -C "$AK3" clean -qdfx -e '*.zip'
    # Kernel image task(s)
    # Copy compressed kernel with appended DTB image
    cp -f out/arch/arm64/boot/Image.gz-dtb "$AK3"

    # Export here to be picked later
    KERNEL_NAME=fk-$DEVICE-$(date +%Y%m%d-%H%M)

    # Set final package names
    UNSIGNED_ZIP=${KERNEL_NAME}-unsigned.zip
    SIGNED_ZIP=${KERNEL_NAME}.zip

    cd "$AK3"
    7z a -mx9 "${UNSIGNED_ZIP}" -x'!'README.md *

    # Sign zip
    java -jar "${BIN_FOLDER}/zipsigner-3.0.jar" \
              "${UNSIGNED_ZIP}" \
              "${SIGNED_ZIP}"

    rm -f "$UNSIGNED_ZIP"
    mv "$AK3/$SIGNED_ZIP" ${HOME}/flatKernel/${DEVICE}
fi

END=$(date +"%s")
DURATION=$(format_time "${START}" "${END}")

echo "\a"
echo "${GRN}DURATION: ${DURATION}${RST}"
